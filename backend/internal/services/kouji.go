package services

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"penguin-backend/internal/models"
	"penguin-backend/internal/utils"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// KoujiService は工事情報取得サービスを提供する
type KoujiService struct {
	FileSystemService *FileSystemService
	Root              string
	Database          string
}

// NewKoujiService はKoujiServiceを初期化する
func NewKoujiService(fsService *FileSystemService, root string, databaseName string) (*KoujiService, error) {
	if filepath.IsAbs(root) {
		return nil, errors.New("absolute path is not allowed")
	}
	database := filepath.Join(root, databaseName)
	return &KoujiService{
		FileSystemService: fsService,
		Root:              root,
		Database:          database,
	}, nil
}

// NewKoujiEntry ファイルエントリから工事エントリを作成します
func NewKoujiEntry(fileEntry models.FileEntry) (models.KoujiEntry, error) {

	if !fileEntry.IsDirectory {
		return models.KoujiEntry{}, fmt.Errorf("ファイルではありません")
	}

	// Parse date from folder name
	parsedDate, restStr, err := utils.ParseTimeAndRest(fileEntry.Name)
	if err != nil {
		return models.KoujiEntry{}, err
	}
	startDate := models.Timestamp{
		Time: parsedDate,
	}

	// restStr is like "豊田築炉 名和工場 詳細"
	// companyName は会社名(ex. 豊田築炉)
	// locationName は会社名以降の文字列(ex. "名和工場 詳細")
	parts := strings.Split(restStr, " ")
	companyName := parts[0]
	locationName := ""
	if len(parts) > 1 {
		locationName = strings.Join(parts[1:], " ")
	}

	// Generate unique project ID using folder creation date, company name, and location name
	// This ensures the same project always gets the same ID
	// Use project date instead of creation date for more stable ID generation
	idSource := fmt.Sprintf("%d%s%s", fileEntry.ID, companyName, locationName)
	id := models.NewIDFromString(idSource)

	koujiEntry := models.KoujiEntry{
		// Generate project metadata based on folder name
		ID:           id.Len5(),
		CompanyName:  companyName,
		LocationName: locationName,
		StartDate:    startDate,
		EndDate:      startDate,
		Status:       DetermineKoujiStatus(startDate, startDate),
		Description:  companyName + "の" + locationName + "における工事プロジェクト",
		Tags:         []string{"工事", companyName, locationName, startDate.Time.Format("2006")}, // Include year as tag
		// FileEntry: ファイルシステムから取得したフォルダー情報
		FileEntry: fileEntry,
	}

	return koujiEntry, nil
}

// GetKoujiEntries は指定されたパスから工事一覧を取得する（ファイルシステムとデータベースをマージ）
func (s *KoujiService) GetKoujiEntries() []models.KoujiEntry {
	// ファイルシステムから工事を取得
	fsEntries := s.GetKoujiEntriesFromFileSystem()

	// データベースから工事を取得とマップの作成
	dbEntries := s.GetKoujiEntriesFromDatabase()
	dbEntryMap := KoujiEntriesToMapByID(dbEntries)

	// モデルの情報です。
	// Id           string    `json:"id,omitempty" yaml:"id" example:"Generated by Folder ID + CompanyName + LocationName"`
	// CompanyName  string    `json:"company_name,omitempty" yaml:"company_name" example:"豊田築炉"`
	// LocationName string    `json:"location_name,omitempty" yaml:"location_name" example:"名和工場"`
	// Status       string    `json:"status,omitempty" yaml:"status" example:"進行中"`
	// StartDate    Timestamp `json:"start_date,omitempty" yaml:"start_date"`
	// EndDate      Timestamp `json:"end_date,omitempty" yaml:"end_date"`
	// Description  string    `json:"description,omitempty" yaml:"description" example:"工事関連の資料とドキュメント"`
	// Tags         []string  `json:"tags,omitempty" yaml:"tags" example:"['工事', '豊田築炉', '名和工場']"`
	// FileCount    int       `json:"file_count,omitempty" yaml:"file_count" example:"42"`
	// SubdirCount  int       `json:"subdir_count,omitempty" yaml:"subdir_count" example:"5"`
	// // Embed the base FileEntry struct
	// FileEntry

	// ファイルシステムの工事一覧を更新する
	updatedEntries := make([]models.KoujiEntry, 0, len(fsEntries))
	for _, fsEntry := range fsEntries {
		if dbEntry, exists := dbEntryMap[fsEntry.ID]; exists {
			// データベースに情報が存在しているときの処理
			fsEntry.StartDate = dbEntry.StartDate
			fsEntry.EndDate = dbEntry.EndDate
			fsEntry.Description = dbEntry.Description
			fsEntry.Status = DetermineKoujiStatus(fsEntry.StartDate, fsEntry.EndDate)
			fsEntry.Tags = dbEntry.Tags
			updatedEntries = append(updatedEntries, fsEntry)

			// Remove from map so we don't add it again
			delete(dbEntryMap, fsEntry.ID)
		} else {
			// New project from file system - add it
			updatedEntries = append(updatedEntries, fsEntry)
		}
	}

	// 開始日の降順でソート（新しい順）
	sort.Slice(updatedEntries, func(i, j int) bool {
		return updatedEntries[i].StartDate.Time.After(updatedEntries[j].StartDate.Time)
	})

	// データベースに保存
	s.SaveKoujiEntries(updatedEntries)

	return updatedEntries
}

// GetKoujiEntriesFromFileSystem はファイルシステムから工事一覧を取得する
func (s *KoujiService) GetKoujiEntriesFromFileSystem() []models.KoujiEntry {
	// Get kouji fileEntries from file system
	fileEntries, err := s.FileSystemService.GetFileEntries(s.Root)
	if err != nil {
		return []models.KoujiEntry{}
	}

	// Convert to KoujiEntries with additional metadata
	koujiEntries := make([]models.KoujiEntry, 0, len(fileEntries.FileEntries))
	for _, entry := range fileEntries.FileEntries {
		koujiEntry, err := NewKoujiEntry(entry)
		if err != nil {
			// 工事フォルダーとして解析できない場合はスキップ
			continue
		}
		koujiEntries = append(koujiEntries, koujiEntry)
	}

	return koujiEntries
}

// GetKoujiEntriesFromDatabase は工事情報をYAMLファイルから読み込む
func (s *KoujiService) GetKoujiEntriesFromDatabase() []models.KoujiEntry {
	databasePath, err := s.FileSystemService.BuildPath(s.Database)
	if err != nil {
		return []models.KoujiEntry{}
	}

	// Check if file exists
	if _, err := os.Stat(databasePath); os.IsNotExist(err) {
		return []models.KoujiEntry{} // Return empty list if file doesn't exist
	}

	// Read YAML file
	yamlData, err := os.ReadFile(databasePath)
	if err != nil {
		return []models.KoujiEntry{}
	}

	var dbEntries []models.KoujiEntry
	if err := yaml.Unmarshal(yamlData, &dbEntries); err != nil {
		return []models.KoujiEntry{}
	}

	return dbEntries
}

// ConvertToMap は[]KoujiEntryをmap[string]KoujiEntryに変換する
func KoujiEntriesToMapByID(entries []models.KoujiEntry) map[string]models.KoujiEntry {
	entryMap := make(map[string]models.KoujiEntry, len(entries))
	for _, entry := range entries {
		entryMap[entry.ID] = entry
	}
	return entryMap
}

// DetermineKoujiStatus determines the project status based on the date
func DetermineKoujiStatus(startDate models.Timestamp, endDate models.Timestamp) string {
	if startDate.Time.IsZero() {
		return "不明"
	}

	now := time.Now()

	if now.Before(startDate.Time) {
		return "予定"
	} else if now.After(endDate.Time) {
		return "完了"
	} else {
		return "進行中"
	}
}

// UpdateProjectDates はプロジェクトの開始日と終了日を更新する
func (s *KoujiService) UpdateProjectDates(id string, startDate, endDate models.Timestamp) (models.KoujiEntry, error) {
	// データベースから工事一覧を取得
	dbEntries := s.GetKoujiEntriesFromDatabase()

	// Find and update the project
	foundIndex := -1
	for i, entry := range dbEntries {
		if entry.ID == id {
			dbEntries[i].StartDate = startDate
			dbEntries[i].EndDate = endDate
			dbEntries[i].Status = DetermineKoujiStatus(startDate, endDate)
			foundIndex = i
			break
		}
	}

	if foundIndex == -1 {
		return models.KoujiEntry{}, fmt.Errorf("工事情報がデータベースにありません: %s", id)
	}

	// Save updated kouji entries to YAML
	err := s.SaveKoujiEntries(dbEntries)

	// 更新した工事を返す
	return dbEntries[foundIndex], err
}

// SaveKoujiEntries は引数のkoujiEntriesをデータベースに保存する
func (s *KoujiService) SaveKoujiEntries(entries []models.KoujiEntry) error {
	// 引数の工事一覧をmapに変換する
	entryMap := KoujiEntriesToMapByID(entries)

	// データベースから工事一覧を取得
	fsEntries := s.GetKoujiEntriesFromFileSystem()

	// ファイルシステムの工事一覧を更新する
	updatedEntries := make([]models.KoujiEntry, 0, len(fsEntries))
	for _, fsEntry := range fsEntries {
		if dbEntry, exists := entryMap[fsEntry.ID]; exists {
			// データベースに情報が存在しているときの処理
			fsEntry.StartDate = dbEntry.StartDate
			fsEntry.EndDate = dbEntry.EndDate
			fsEntry.Description = dbEntry.Description
			fsEntry.Status = DetermineKoujiStatus(fsEntry.StartDate, fsEntry.EndDate)
			fsEntry.Tags = dbEntry.Tags
			updatedEntries = append(updatedEntries, fsEntry)

			// Remove from map so we don't add it again
			delete(entryMap, fsEntry.ID)
		} else {
			// New project from file system - add it
			updatedEntries = append(updatedEntries, fsEntry)
		}
	}
	yamlData, err := yaml.Marshal(updatedEntries)
	if err != nil {
		return err
	}

	databasePath, err := s.FileSystemService.BuildPath(s.Database)
	if err != nil {
		return err
	}

	return os.WriteFile(databasePath, yamlData, 0644)
}
