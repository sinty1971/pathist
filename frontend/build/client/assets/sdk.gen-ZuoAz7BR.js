var q=Object.defineProperty;var _=(r,t,e)=>t in r?q(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var x=(r,t,e)=>_(r,typeof t!="symbol"?t+"":t,e);const U={bodySerializer:r=>JSON.stringify(r,(t,e)=>typeof e=="bigint"?e.toString():e)},E=async(r,t)=>{const e=typeof t=="function"?await t(r):t;if(e)return r.scheme==="bearer"?`Bearer ${e}`:r.scheme==="basic"?`Basic ${btoa(e)}`:e},T=r=>{switch(r){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},P=r=>{switch(r){case"form":return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20";default:return","}},W=r=>{switch(r){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},A=({allowReserved:r,explode:t,name:e,style:i,value:a})=>{if(!t){const n=(r?a:a.map(c=>encodeURIComponent(c))).join(P(i));switch(i){case"label":return`.${n}`;case"matrix":return`;${e}=${n}`;case"simple":return n;default:return`${e}=${n}`}}const o=T(i),s=a.map(n=>i==="label"||i==="simple"?r?n:encodeURIComponent(n):g({allowReserved:r,name:e,value:n})).join(o);return i==="label"||i==="matrix"?o+s:s},g=({allowReserved:r,name:t,value:e})=>{if(e==null)return"";if(typeof e=="object")throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${r?e:encodeURIComponent(e)}`},$=({allowReserved:r,explode:t,name:e,style:i,value:a,valueOnly:o})=>{if(a instanceof Date)return o?a.toISOString():`${e}=${a.toISOString()}`;if(i!=="deepObject"&&!t){let c=[];Object.entries(a).forEach(([d,b])=>{c=[...c,d,r?b:encodeURIComponent(b)]});const l=c.join(",");switch(i){case"form":return`${e}=${l}`;case"label":return`.${l}`;case"matrix":return`;${e}=${l}`;default:return l}}const s=W(i),n=Object.entries(a).map(([c,l])=>g({allowReserved:r,name:i==="deepObject"?`${e}[${c}]`:c,value:l})).join(s);return i==="label"||i==="matrix"?s+n:n},k=/\{[^{}]+\}/g,H=({path:r,url:t})=>{let e=t;const i=t.match(k);if(i)for(const a of i){let o=!1,s=a.substring(1,a.length-1),n="simple";s.endsWith("*")&&(o=!0,s=s.substring(0,s.length-1)),s.startsWith(".")?(s=s.substring(1),n="label"):s.startsWith(";")&&(s=s.substring(1),n="matrix");const c=r[s];if(c==null)continue;if(Array.isArray(c)){e=e.replace(a,A({explode:o,name:s,style:n,value:c}));continue}if(typeof c=="object"){e=e.replace(a,$({explode:o,name:s,style:n,value:c,valueOnly:!0}));continue}if(n==="matrix"){e=e.replace(a,`;${g({name:s,value:c})}`);continue}const l=encodeURIComponent(n==="label"?`.${c}`:c);e=e.replace(a,l)}return e},z=({allowReserved:r,array:t,object:e}={})=>a=>{const o=[];if(a&&typeof a=="object")for(const s in a){const n=a[s];if(n!=null)if(Array.isArray(n)){const c=A({allowReserved:r,explode:!0,name:s,style:"form",value:n,...t});c&&o.push(c)}else if(typeof n=="object"){const c=$({allowReserved:r,explode:!0,name:s,style:"deepObject",value:n,...e});c&&o.push(c)}else{const c=g({allowReserved:r,name:s,value:n});c&&o.push(c)}}return o.join("&")},D=r=>{var e;if(!r)return"stream";const t=(e=r.split(";")[0])==null?void 0:e.trim();if(t){if(t.startsWith("application/json")||t.endsWith("+json"))return"json";if(t==="multipart/form-data")return"formData";if(["application/","audio/","image/","video/"].some(i=>t.startsWith(i)))return"blob";if(t.startsWith("text/"))return"text"}},N=async({security:r,...t})=>{for(const e of r){const i=await E(e,t.auth);if(!i)continue;const a=e.name??"Authorization";switch(e.in){case"query":t.query||(t.query={}),t.query[a]=i;break;case"cookie":t.headers.append("Cookie",`${a}=${i}`);break;case"header":default:t.headers.set(a,i);break}return}},S=r=>V({baseUrl:r.baseUrl,path:r.path,query:r.query,querySerializer:typeof r.querySerializer=="function"?r.querySerializer:z(r.querySerializer),url:r.url}),V=({baseUrl:r,path:t,query:e,querySerializer:i,url:a})=>{const o=a.startsWith("/")?a:`/${a}`;let s=(r??"")+o;t&&(s=H({path:t,url:s}));let n=e?i(e):"";return n.startsWith("?")&&(n=n.substring(1)),n&&(s+=`?${n}`),s},w=(r,t)=>{var i;const e={...r,...t};return(i=e.baseUrl)!=null&&i.endsWith("/")&&(e.baseUrl=e.baseUrl.substring(0,e.baseUrl.length-1)),e.headers=O(r.headers,t.headers),e},O=(...r)=>{const t=new Headers;for(const e of r){if(!e||typeof e!="object")continue;const i=e instanceof Headers?e.entries():Object.entries(e);for(const[a,o]of i)if(o===null)t.delete(a);else if(Array.isArray(o))for(const s of o)t.append(a,s);else o!==void 0&&t.set(a,typeof o=="object"?JSON.stringify(o):o)}return t};class j{constructor(){x(this,"_fns");this._fns=[]}clear(){this._fns=[]}getInterceptorIndex(t){return typeof t=="number"?this._fns[t]?t:-1:this._fns.indexOf(t)}exists(t){const e=this.getInterceptorIndex(t);return!!this._fns[e]}eject(t){const e=this.getInterceptorIndex(t);this._fns[e]&&(this._fns[e]=null)}update(t,e){const i=this.getInterceptorIndex(t);return this._fns[i]?(this._fns[i]=e,t):!1}use(t){return this._fns=[...this._fns,t],this._fns.length-1}}const R=()=>({error:new j,request:new j,response:new j}),B=z({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),J={"Content-Type":"application/json"},C=(r={})=>({...U,headers:J,parseAs:"auto",querySerializer:B,...r}),F=(r={})=>{let t=w(C(),r);const e=()=>({...t}),i=s=>(t=w(t,s),e()),a=R(),o=async s=>{const n={...t,...s,fetch:s.fetch??t.fetch??globalThis.fetch,headers:O(t.headers,s.headers)};n.security&&await N({...n,security:n.security}),n.body&&n.bodySerializer&&(n.body=n.bodySerializer(n.body)),(n.body===void 0||n.body==="")&&n.headers.delete("Content-Type");const c=S(n),l={redirect:"follow",...n};let d=new Request(c,l);for(const u of a.request._fns)u&&(d=await u(d,n));const b=n.fetch;let f=await b(d);for(const u of a.response._fns)u&&(f=await u(f,d,n));const m={request:d,response:f};if(f.ok){if(f.status===204||f.headers.get("Content-Length")==="0")return n.responseStyle==="data"?{}:{data:{},...m};const u=(n.parseAs==="auto"?D(f.headers.get("Content-Type")):n.parseAs)??"json";if(u==="stream")return n.responseStyle==="data"?f.body:{data:f.body,...m};let p=await f[u]();return u==="json"&&(n.responseValidator&&await n.responseValidator(p),n.responseTransformer&&(p=await n.responseTransformer(p))),n.responseStyle==="data"?p:{data:p,...m}}let y=await f.text();try{y=JSON.parse(y)}catch{}let h=y;for(const u of a.error._fns)u&&(h=await u(y,f,d,n));if(h=h||{},n.throwOnError)throw h;return n.responseStyle==="data"?void 0:{error:h,...m}};return{buildUrl:S,connect:s=>o({...s,method:"CONNECT"}),delete:s=>o({...s,method:"DELETE"}),get:s=>o({...s,method:"GET"}),getConfig:e,head:s=>o({...s,method:"HEAD"}),interceptors:a,options:s=>o({...s,method:"OPTIONS"}),patch:s=>o({...s,method:"PATCH"}),post:s=>o({...s,method:"POST"}),put:s=>o({...s,method:"PUT"}),request:o,setConfig:i,trace:s=>o({...s,method:"TRACE"})}},I=F(C({baseUrl:"http://localhost:8080/api"})),Q=r=>((r==null?void 0:r.client)??I).get({url:"/file/fileinfos",...r}),G=r=>((r==null?void 0:r.client)??I).get({url:"/project/recent",...r});export{G as a,Q as g};
